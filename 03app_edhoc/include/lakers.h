/*
 * ================================================================================================
 *  WARNING: This file is automatically generated by cbindgen. Manual edits are likely to be lost.
 * ================================================================================================
 */

#ifndef LAKERS_C_H
#define LAKERS_C_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "lakers_shared.h"
#include "lakers_ead_authz.h"

typedef struct CredentialC {
  BufferCred bytes;
  CredentialKey key;
  /**
   * differs from Rust: here we assume the kid is always present
   * this is to simplify the C API, since C doesn't support Option<T>
   * the alternative would be to use a pointer, but then we need to care about memory management
   */
  BufferKid kid;
  CredentialType cred_type;
} CredentialC;

typedef struct EadAuthzDevice {
  ZeroTouchDevice start;
  ZeroTouchDeviceWaitEAD2 wait_ead2;
  ZeroTouchDeviceDone done;
} EadAuthzDevice;

/**
 * Note that while the Rust version supports optional value to indicate an empty value,
 * in the C version we use an empty buffer for that case.
 */
typedef struct EADItemC {
  uint8_t label;
  bool is_critical;
  EdhocMessageBuffer value;
} EADItemC;

typedef struct ProcessingM2C {
  BytesMac2 mac_2;
  BytesHashLen prk_2e;
  BytesHashLen th_2;
  BytesP256ElemLen x;
  BytesP256ElemLen g_y;
  EdhocMessageBuffer plaintext_2;
  uint8_t c_r;
  IdCred id_cred_r;
  struct EADItemC *ead_2;
} ProcessingM2C;

/**
 * structs compatible with the C FFI
 */
typedef struct EdhocInitiator {
  InitiatorStart start;
  WaitM2 wait_m2;
  struct ProcessingM2C processing_m2;
  ProcessedM2 processed_m2;
  struct CredentialC *cred_i;
  Completed completed;
} EdhocInitiator;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int8_t credential_new(struct CredentialC *cred, const uint8_t *value, uintptr_t value_len);

int8_t credential_check_or_fetch(struct CredentialC *cred_expected,
                                 IdCred *id_cred_received,
                                 struct CredentialC *cred_out);

void p256_generate_key_pair_from_c(uint8_t *out_private_key, uint8_t *out_public_key);

int8_t authz_device_new(struct EadAuthzDevice *device_c,
                        const uint8_t *id_u,
                        uintptr_t id_u_len,
                        const BytesP256ElemLen *g_w,
                        const uint8_t *loc_w,
                        uintptr_t loc_w_len);

int8_t authz_device_prepare_ead_1(struct EadAuthzDevice *device_c,
                                  const BytesP256ElemLen *secret,
                                  uint8_t ss,
                                  struct EADItemC *ead_1_c_out);

int8_t authz_device_process_ead_2(struct EadAuthzDevice *device_c,
                                  struct EADItemC *ead_2_c,
                                  struct CredentialC *cred_v);

int8_t initiator_new(struct EdhocInitiator *initiator);

int8_t initiator_prepare_message_1(struct EdhocInitiator *initiator_c,
                                   uint8_t *c_i,
                                   struct EADItemC *ead_1_c,
                                   EdhocMessageBuffer *message_1);

int8_t initiator_parse_message_2(struct EdhocInitiator *initiator_c,
                                 const EdhocMessageBuffer *message_2,
                                 uint8_t *c_r_out,
                                 IdCred *id_cred_r_out,
                                 struct EADItemC *ead_2_c_out);

int8_t initiator_verify_message_2(struct EdhocInitiator *initiator_c,
                                  const BytesP256ElemLen *i,
                                  struct CredentialC *cred_i,
                                  struct CredentialC *valid_cred_r);

int8_t initiator_prepare_message_3(struct EdhocInitiator *initiator_c,
                                   CredentialTransfer cred_transfer,
                                   struct EADItemC *ead_3_c,
                                   EdhocMessageBuffer *message_3,
                                   uint8_t (*prk_out_c)[SHA256_DIGEST_LEN]);

int8_t initiator_compute_ephemeral_secret(const struct EdhocInitiator *initiator_c,
                                          const BytesP256ElemLen *g_a,
                                          BytesP256ElemLen *secret_c_out);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* LAKERS_C_H */
